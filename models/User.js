const usersCollection = require('../db').db().collection("users")
const validator = require("validator")
const bcrypt = require("bcryptjs")
const md5 = require("md5")
const { promiseImpl } = require('ejs')


let User = function(data, getAvatar){
    //takes the data that just got entered into a parameter we can access again later. 
    this.data0 = data
    //stores any errors generated by user in the registration process in this array
    this.errors = []

    if(getAvatar == undefined){getAvatar = false}
    if(getAvatar) {this.getAvatar()}

}

User.prototype.cleanUp = function(){
    if (typeof(this.data0.username) != "string"){this.data0.username = ""}
    if (typeof(this.data0.email) != "string"){this.data0.email = ""}
    if (typeof(this.data0.password) != "string"){this.data0.password = ""}

    // get rid of any bogus properties. maintain good data integrity so users cannot inject bogus or malicious data
    this.data0 = {
        //trim method removes blank spaces
        username: this.data0.username.trim(),
        email: this.data0.email.trim().toLowerCase(),
        password: this.data0.password,        
        avatarbgcolor: this.data0.avatarbgcolor
    }

}

User.prototype.validate = function(){
    return new Promise(async (resolve, reject) => {
        if(this.data0.username == ""){this.errors.push("username cannot be blank :o")}
        if(this.data0.username != "" && !validator.isAlphanumeric(this.data0.username)){this.errors.push("usernames can only contain letters and numbers")}
        //the exclaimation point means if data is NOT an email
        if(!validator.isEmail(this.data0.email)){this.errors.push("sorry, you'll need a valid email address to join O_o")}
        if(this.data0.password == ""){this.errors.push("password cannot be blank :x")}
        if(this.data0.password.length > 0 && this.data0.password.length < 8){this.errors.push("password must be at least 8 characters")}
        if(this.data0.password.length > 50){this.errors.push("this password is a bit long! Let's keep it under 50 characters.")}
        if(this.data0.username.length > 0 && this.data0.username.length < 3){this.errors.push("username must be at least 3 characters")}
        if(this.data0.username.length > 30){this.errors.push("your username is a bit long! Let's keep it under 30 characters.")}
        
        // make sure usernames / emails are unique. Make sure it's even valid first to be efficient
        if (this.data0.username.length > 2 && this.data0.username.length < 31 && validator.isAlphanumeric(this.data0.username)){
            let usernameExists = await usersCollection.findOne({username: this.data0.username})
    
            if (usernameExists){this.errors.push("That member name is already taken.")}
        }
        if (validator.isEmail(this.data0.email)){
            let emailExists = await usersCollection.findOne({email: this.data0.email})
    
            if (emailExists){this.errors.push("A member is already using that email.")}
        }
        resolve()
    })
}



User.prototype.login = function(){
    return new Promise((resolve, reject) => {
        this.cleanUp()
        usersCollection.findOne({username: this.data0.username}).then((attemptedUser)=>{
            if (attemptedUser && bcrypt.compareSync(this.data0.password, attemptedUser.password)){
                this.data0 = attemptedUser
                this.getAvatar()
                resolve("Welcome - You're in.")
            }else {
                reject('Member / password not found')
            }
        }).catch(function() {
            reject("Hmmm. Something went wrong. Please try again later.")
        })
    })
}


User.prototype.register = function(){
    return new Promise(async (resolve, reject) => {
        //Step 1: validate the user entry values
        this.cleanUp()
        await this.validate()
        
        //Step 2: Only if there are no validation errors
        //        then save the user data into a database
        if (!this.errors.length){
           // hash user password
           // step 1: make a salt
           let salt = bcrypt.genSaltSync(10)
           // step 2 overwrite pass data
           this.data0.password = bcrypt.hashSync(this.data0.password, salt)
            await usersCollection.insertOne(this.data0)
            this.getAvatar()
            resolve()
        } else {
            reject(this.errors)
        }    
    })
}

User.prototype.getAvatar = function() {
    
    this.avatar = `https://i.ibb.co/v45JwwP/superdraft-Avatar-Placeholder-Outlined.png`     
}

User.findByUsername = function(username){
    return new Promise(function(resolve, reject){
        if(typeof(username) != "string"){
            reject()
            return
        } 

        usersCollection.findOne({username: username}).then(function(userDoc){
            if(userDoc){
                userDoc = new User(userDoc, true)
                userDoc = {
                    _id: userDoc.data0._id,
                    username: userDoc.data0.username,
                    avatar: userDoc.avatar,
                    avatarbgcolor: userDoc.data0.avatarbgcolor

                }
                resolve(userDoc)
            } else {
                reject()
            }
        }).catch(function(){
            reject()
        })
    })
}

User.doesEmailExist = function(email) {
    return new Promise(async function(resolve, reject) {
        if (typeof(email) != "string"){
            resolve(false)
            // stop any further execution of fn so sus data doesnt go to mongodb
            return
        }
        
        // this is where we check to see if there is already an existing email in the db
        let user = await usersCollection.findOne({email: email})

        if (user) {
            resolve(true)
        } else {
            resolve(false)
        }
    })
}

module.exports = User